import WeakishMap from './WeakishMap';
import { assignArraylike, arraylikeToIterable, getDefaultLazy, isObject } from './helpers';
export default class Tuple extends Array {
    /**
     * @throws {TypeError} Will throw if called non-locally; use the tuple() method instead.
     */
    constructor(iterable, confirm) {
        super();
        this.length = 0;
        // TODO: make configurable or remove? it currently breaks subclassing
        if (confirm !== localToken) {
            throw TypeError('The `Tuple.tuple()` method must be used to construct');
        }
        assignArraylike(iterable[Symbol.iterator](), this);
        Object.freeze(this);
    }
    static tuple(...values) {
        // Special case for 0-tuples
        if (values.length === 0) {
            // Only construct if needed
            if (tuple0 === undefined) {
                tuple0 = new Tuple([], localToken);
            }
            return tuple0;
        }
        return getDefaultLazy(tupleKey, () => new Tuple(values, localToken), getLeaf(values));
    }
    static symbol(...values) {
        return getDefaultLazy(symbolKey, () => Symbol(), getLeaf(values));
    }
    /**
     * A tuple whose members are allowed to all be primitive,
     * so it can't be garbage-collected and should only be used
     * in advanced contexts.
     */
    static unsafe(...values) {
        return getDefaultLazy(tupleKey, () => new UnsafeTuple(values, localToken), getUnsafeLeaf(values));
    }
    static unsafeSymbol(...values) {
        return getDefaultLazy(symbolKey, Symbol, getUnsafeLeaf(values));
    }
    [Symbol.iterator]() {
        return arraylikeToIterable(this);
    }
}
// Root cache keys for each tuple type
const tupleKey = Symbol();
const symbolKey = Symbol();
const cache = new WeakishMap();
// Token used to prevent calling the constructor from other modules
const localToken = Symbol();
const initWeakish = () => new WeakishMap();
let tuple0;
/**
 * Tries to use the first non-primitive from value list as the root key and throws
 * if there's only primitives.
 */
export const getLeaf = (values, unsafe) => {
    const rootValue = values.find(isObject);
    if (!rootValue && !unsafe) {
        // Throw since it's not possible to weak-reference objects by primitives, only by other objects
        throw TypeError('At least one value must be of type object');
    }
    // If the first value is not an object, pad the values with the first object
    const root = rootValue === values[0] ? cache : getDefaultLazy(rootValue, initWeakish, cache);
    return values.reduce((prev, curr) => getDefaultLazy(curr, initWeakish, prev), root);
};
// Unsafe tuples aren't garbage collected so it's more efficient to just use a normal map
const unsafeCache = new Map();
const initUnsafe = () => new Map();
class UnsafeTuple extends Tuple {
}
/**
 * A memory-leaky, slightly more efficient version of `getLeaf()`.
 */
export const getUnsafeLeaf = (values) => values.reduce((prev, curr) => getDefaultLazy(curr, initUnsafe, prev), unsafeCache);
export const { tuple, symbol } = Tuple;
export const unsafe = Tuple.unsafe;
export const unsafeSymbol = Tuple.unsafeSymbol;
// Expose constructor to be used for `instanceof`
tuple.constructor = Tuple;
unsafe.constructor = UnsafeTuple;
//# sourceMappingURL=Tuple.js.map