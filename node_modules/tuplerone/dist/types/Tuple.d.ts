import WeakishMap from './WeakishMap';
import { Tuple0, Tuple1, Tuple2, Tuple3, Tuple4, Tuple5, Tuple6, Tuple7, Tuple8, CompositeSymbol0, CompositeSymbol1, CompositeSymbol2, CompositeSymbol3, CompositeSymbol4, CompositeSymbol5, CompositeSymbol6, CompositeSymbol7, CompositeSymbol8 } from './types';
declare const Tuple_base: any;
export default class Tuple<A> extends Tuple_base implements ArrayLike<A>, Iterable<A> {
    [i: number]: A;
    length: number;
    /**
     * @throws {TypeError} Will throw if called non-locally; use the tuple() method instead.
     */
    constructor(iterable: Iterable<A>, confirm: typeof localToken);
    /**
     * Constructs a tuple.
     */
    static tuple<A, B, C, D, E, F, G, H>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H): Tuple8<A, B, C, D, E, F, G, H>;
    static tuple<A, B, C, D, E, F, G>(a: A, b: B, c: C, d: D, e: E, f: F, g: G): Tuple7<A, B, C, D, E, F, G>;
    static tuple<A, B, C, D, E, F>(a: A, b: B, c: C, d: D, e: E, f: F): Tuple6<A, B, C, D, E, F>;
    static tuple<A, B, C, D, E>(a: A, b: B, c: C, d: D, e: E): Tuple5<A, B, C, D, E>;
    static tuple<A, B, C, D>(a: A, b: B, c: C, d: D): Tuple4<A, B, C, D>;
    static tuple<A, B, C>(a: A, b: B, c: C): Tuple3<A, B, C>;
    static tuple<A, B>(a: A, b: B): Tuple2<A, B>;
    static tuple<A>(a: A): Tuple1<A>;
    static tuple(): Tuple0;
    static symbol<A, B, C, D, E, F, G, H>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H): CompositeSymbol8<A, B, C, D, E, F, G, H>;
    static symbol<A, B, C, D, E, F, G>(a: A, b: B, c: C, d: D, e: E, f: F, g: G): CompositeSymbol7<A, B, C, D, E, F, G>;
    static symbol<A, B, C, D, E, F>(a: A, b: B, c: C, d: D, e: E, f: F): CompositeSymbol6<A, B, C, D, E, F>;
    static symbol<A, B, C, D, E>(a: A, b: B, c: C, d: D, e: E): CompositeSymbol5<A, B, C, D, E>;
    static symbol<A, B, C, D>(a: A, b: B, c: C, d: D): CompositeSymbol4<A, B, C, D>;
    static symbol<A, B, C>(a: A, b: B, c: C): CompositeSymbol3<A, B, C>;
    static symbol<A, B>(a: A, b: B): CompositeSymbol2<A, B>;
    static symbol<A>(a: A): CompositeSymbol1<A>;
    static symbol(): typeof CompositeSymbol0;
    /**
     * A tuple whose members are allowed to all be primitive,
     * so it can't be garbage-collected and should only be used
     * in advanced contexts.
     */
    static unsafe(...values: any[]): any;
    static unsafeSymbol(...values: any[]): any;
    [Symbol.iterator](): IterableIterator<A>;
}
declare const localToken: unique symbol;
/**
 * Tries to use the first non-primitive from value list as the root key and throws
 * if there's only primitives.
 */
export declare const getLeaf: (values: any[], unsafe?: boolean | undefined) => WeakishMap<any, any>;
/**
 * A memory-leaky, slightly more efficient version of `getLeaf()`.
 */
export declare const getUnsafeLeaf: (values: any[]) => Map<any, any>;
export declare const tuple: typeof Tuple.tuple, symbol: typeof Tuple.symbol;
export declare const unsafe: typeof Tuple.tuple;
export declare const unsafeSymbol: typeof Tuple.tuple;
export {};
