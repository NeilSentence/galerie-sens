interface Tuple0 extends Tuple<never> {
    readonly length: 0;
} /** Singleton */
/** Singleton */
interface Tuple1<A> extends Tuple<A> {
    readonly 0: A;
    readonly length: 1;
} /** Pair */
/** Pair */
interface Tuple2<A, B> extends Tuple<A | B> {
    readonly 0: A;
    readonly 1: B;
    readonly length: 2;
} /** Triple */
/** Triple */
interface Tuple3<A, B, C> extends Tuple<A | B | C> {
    readonly 0: A;
    readonly 1: B;
    readonly 2: C;
    readonly length: 3;
} /** Quadruple */
/** Quadruple */
interface Tuple4<A, B, C, D> extends Tuple<A | B | C | D> {
    readonly 0: A;
    readonly 1: B;
    readonly 2: C;
    readonly 3: D;
    readonly length: 4;
} /** Quintuple */
/** Quintuple */
interface Tuple5<A, B, C, D, E> extends Tuple<A | B | C | D | E> {
    readonly 0: A;
    readonly 1: B;
    readonly 2: C;
    readonly 3: D;
    readonly 4: E;
    readonly length: 5;
} /** Sextuple */
/** Sextuple */
interface Tuple6<A, B, C, D, E, F> extends Tuple<A | B | C | D | E | F> {
    readonly 0: A;
    readonly 1: B;
    readonly 2: C;
    readonly 3: D;
    readonly 4: E;
    readonly 5: F;
    readonly length: 6;
} /** Septuple */
/** Septuple */
interface Tuple7<A, B, C, D, E, F, G> extends Tuple<A | B | C | D | E | F | G> {
    readonly 0: A;
    readonly 1: B;
    readonly 2: C;
    readonly 3: D;
    readonly 4: E;
    readonly 5: F;
    readonly 6: G;
    readonly length: 7;
} /** Octuple */
/** Octuple */
interface Tuple8<A, B, C, D, E, F, G, H> extends Tuple<A | B | C | D | E | F | G | H> {
    readonly 0: A;
    readonly 1: B;
    readonly 2: C;
    readonly 3: D;
    readonly 4: E;
    readonly 5: F;
    readonly 6: G;
    readonly 7: H;
    readonly length: 8;
}
type CompositeSymbol<T> = {
    t: T;
} & symbol; // tslint:disable-next-line: variable-name
// tslint:disable-next-line: variable-name
declare const CompositeSymbol0: CompositeSymbol<[never]>;
type CompositeSymbol1<A> = CompositeSymbol<[A]>;
type CompositeSymbol2<A, B> = CompositeSymbol<[A, B]>;
type CompositeSymbol3<A, B, C> = CompositeSymbol<[A, B, C]>;
type CompositeSymbol4<A, B, C, D> = CompositeSymbol<[A, B, C, D]>;
type CompositeSymbol5<A, B, C, D, E> = CompositeSymbol<[A, B, C, D, E]>;
type CompositeSymbol6<A, B, C, D, E, F> = CompositeSymbol<[A, B, C, D, E, F]>;
type CompositeSymbol7<A, B, C, D, E, F, G> = CompositeSymbol<[A, B, C, D, E, F, G]>;
type CompositeSymbol8<A, B, C, D, E, F, G, H> = CompositeSymbol<[A, B, C, D, E, F, G, H]>;
declare const Tuple_base: any;
declare class Tuple<A> extends Tuple_base implements ArrayLike<A>, Iterable<A> {
    [i: number]: A;
    length: number;
    /**
     * @throws {TypeError} Will throw if called non-locally; use the tuple() method instead.
     */
    constructor(iterable: Iterable<A>, confirm: typeof localToken);
    /**
     * Constructs a tuple.
     */
    static tuple<A, B, C, D, E, F, G, H>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H): Tuple8<A, B, C, D, E, F, G, H>;
    static tuple<A, B, C, D, E, F, G>(a: A, b: B, c: C, d: D, e: E, f: F, g: G): Tuple7<A, B, C, D, E, F, G>;
    static tuple<A, B, C, D, E, F>(a: A, b: B, c: C, d: D, e: E, f: F): Tuple6<A, B, C, D, E, F>;
    static tuple<A, B, C, D, E>(a: A, b: B, c: C, d: D, e: E): Tuple5<A, B, C, D, E>;
    static tuple<A, B, C, D>(a: A, b: B, c: C, d: D): Tuple4<A, B, C, D>;
    static tuple<A, B, C>(a: A, b: B, c: C): Tuple3<A, B, C>;
    static tuple<A, B>(a: A, b: B): Tuple2<A, B>;
    static tuple<A>(a: A): Tuple1<A>;
    static tuple(): Tuple0;
    static symbol<A, B, C, D, E, F, G, H>(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H): CompositeSymbol8<A, B, C, D, E, F, G, H>;
    static symbol<A, B, C, D, E, F, G>(a: A, b: B, c: C, d: D, e: E, f: F, g: G): CompositeSymbol7<A, B, C, D, E, F, G>;
    static symbol<A, B, C, D, E, F>(a: A, b: B, c: C, d: D, e: E, f: F): CompositeSymbol6<A, B, C, D, E, F>;
    static symbol<A, B, C, D, E>(a: A, b: B, c: C, d: D, e: E): CompositeSymbol5<A, B, C, D, E>;
    static symbol<A, B, C, D>(a: A, b: B, c: C, d: D): CompositeSymbol4<A, B, C, D>;
    static symbol<A, B, C>(a: A, b: B, c: C): CompositeSymbol3<A, B, C>;
    static symbol<A, B>(a: A, b: B): CompositeSymbol2<A, B>;
    static symbol<A>(a: A): CompositeSymbol1<A>;
    static symbol(): typeof CompositeSymbol0;
    /**
     * A tuple whose members are allowed to all be primitive,
     * so it can't be garbage-collected and should only be used
     * in advanced contexts.
     */
    static unsafe(...values: any[]): any;
    static unsafeSymbol(...values: any[]): any;
    [Symbol.iterator](): IterableIterator<A>;
} // Root cache keys for each tuple type
// Root cache keys for each tuple type
// Root cache keys for each tuple type
// Token used to prevent calling the constructor from other modules
declare const localToken: unique symbol;
declare const tuple: typeof Tuple.tuple, symbol: typeof Tuple.symbol;
declare const unsafe: typeof Tuple.tuple;
declare const unsafeSymbol: typeof Tuple.tuple; // Expose constructor to be used for `instanceof`
// Expose constructor to be used for `instanceof`
// Expose constructor to be used for `instanceof`
/**
 * Recursively creates a "composite key" (like a "value identity") for
 * an object's entries (key-value pairs).
 */
// tslint:disable-next-line: variable-name
declare const DeepCompositeSymbol: (object: any, filter?: ((entry: [string, any]) => boolean) | undefined) => any;
declare const shallowKey: unique symbol;
declare const shallow: <A extends object>(a: A) => A;
/**
 * Works somewhat similarly to Record in the Record & Tuple proposal:
 * https://github.com/tc39/proposal-record-tuple
 */
// tslint:disable-next-line: variable-name
declare const ValueObject: <A extends any>(target: A, filter?: ((entry: [string, any]) => boolean) | undefined) => A;
declare const memoize: <A extends Function>(fn: A, cache?: WeakMap<object, any>) => A;
export { symbol as CompositeSymbol, unsafeSymbol as UnsafeCompositeSymbol, unsafe as UnsafeTuple, memoize, shallowKey, shallow, DeepCompositeSymbol, ValueObject, tuple as Tuple, tuple as default, Tuple0, Tuple1, Tuple2, Tuple3, Tuple4, Tuple5, Tuple6, Tuple7, Tuple8, CompositeSymbol as CompositeSymbolType, CompositeSymbol0, CompositeSymbol1, CompositeSymbol2, CompositeSymbol3, CompositeSymbol4, CompositeSymbol5, CompositeSymbol6, CompositeSymbol7, CompositeSymbol8 };
