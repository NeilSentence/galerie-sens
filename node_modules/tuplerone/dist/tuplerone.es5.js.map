{"version":3,"file":"tuplerone.es5.js","sources":["../src/helpers.ts","../src/WeakishMap.ts","../src/Tuple.ts","../src/DeepCompositeSymbol.ts","../src/ValueObject.ts","../src/memoize.ts","../src/types.ts"],"sourcesContent":["import { GenericMap, Indexable } from './types';\n\n/**\n * Gets a map element, lazily initializing it with a default value.\n */\nexport const getDefaultLazy = <A, B>(key: A, init: () => B, target: GenericMap<A, B>): B => {\n  if (!target.has(key)) {\n    const value = init();\n    target.set(key, value);\n    return value;\n  }\n  return <B>target.get(key);\n};\n\n/**\n * Gets a map element, initializing it with a default value.\n */\nexport const getDefault = <A, B>(key: A, defaultValue: B, target: GenericMap<A, B>): B => {\n  if (!target.has(key)) {\n    target.set(key, defaultValue);\n    return defaultValue;\n  }\n  return <B>target.get(key);\n};\n\n/**\n * Tests if a value is an object.\n *\n * Doesn't test for symbols because symbols are invalid as `WeakMap` keys.\n */\nexport const isObject = (x: any): x is object =>\n  x !== null && (typeof x === 'object' || typeof x === 'function');\n\nexport const forEach = <A>(iterator: Iterator<A>, callback: (value: A) => void) => {\n  do {\n    const { value, done } = iterator.next();\n    if (done) {\n      break;\n    }\n    callback(value);\n  } while (true);\n};\n\n/**\n * Sets all items from an iterable as index properties on the target object.\n */\nexport const assignArraylike = <A>(iterator: Iterator<A>, target: Indexable<A>): number => {\n  let i = 0;\n  forEach(iterator, (value: A) => {\n    target[i] = value;\n    i += 1;\n  });\n  return i;\n};\n\nexport const arraylikeToIterable = <A>(source: ArrayLike<A>): IterableIterator<A> => {\n  let i = 0;\n  return {\n    next() {\n      let done;\n      let value;\n      if (i < source.length) {\n        done = false;\n        value = source[i];\n        i += 1;\n      } else {\n        done = true;\n        // Issue: https://github.com/Microsoft/TypeScript/issues/2983\n        value = <any>undefined;\n      }\n      return {\n        done,\n        value,\n      };\n    },\n\n    [Symbol.iterator]() {\n      return arraylikeToIterable(source);\n    },\n  };\n};\n","import { GenericMap } from './types';\nimport { isObject } from './helpers';\n\n/**\n * A generic wrapper to Map and WeakMap that can use both non-primitives\n * (objects and symbols) and primitives as keys, creating the underlying\n * storage as needed.\n */\nexport default class WeakishMap<A, B> implements GenericMap<A, B> {\n  private weakMap?: WeakMap<object, B>;\n  private map?: Map<A, B>;\n\n  set(k: A, v: B): this {\n    if (isObject(k)) {\n      if (!this.weakMap) {\n        this.weakMap = new WeakMap();\n      }\n      this.weakMap.set(k, v);\n    } else {\n      if (!this.map) {\n        this.map = new Map();\n      }\n      this.map.set(k, v);\n    }\n    return this;\n  }\n\n  get(k: A): B | undefined {\n    if (isObject(k) && this.weakMap) {\n      return this.weakMap.get(k);\n    }\n    if (this.map) {\n      return this.map.get(k);\n    }\n  }\n\n  has(k: A): boolean {\n    if (isObject(k) && this.weakMap) {\n      return this.weakMap.has(k);\n    }\n    if (this.map) {\n      return this.map.has(k);\n    }\n    return false;\n  }\n}\n","import WeakishMap from './WeakishMap';\nimport {\n  Tuple0,\n  Tuple1,\n  Tuple2,\n  Tuple3,\n  Tuple4,\n  Tuple5,\n  Tuple6,\n  Tuple7,\n  Tuple8,\n  CompositeSymbol0,\n  CompositeSymbol1,\n  CompositeSymbol2,\n  CompositeSymbol3,\n  CompositeSymbol4,\n  CompositeSymbol5,\n  CompositeSymbol6,\n  CompositeSymbol7,\n  CompositeSymbol8,\n} from './types';\nimport { assignArraylike, arraylikeToIterable, getDefaultLazy, isObject } from './helpers';\n\nexport default class Tuple<A> extends (Array as any) implements ArrayLike<A>, Iterable<A> {\n  [i: number]: A;\n  length: number = 0;\n\n  /**\n   * @throws {TypeError} Will throw if called non-locally; use the tuple() method instead.\n   */\n  constructor(iterable: Iterable<A>, confirm: typeof localToken) {\n    super();\n    // TODO: make configurable or remove? it currently breaks subclassing\n    if (confirm !== localToken) {\n      throw TypeError('The `Tuple.tuple()` method must be used to construct');\n    }\n    assignArraylike(iterable[Symbol.iterator](), this);\n    Object.freeze(this);\n  }\n\n  /**\n   * Constructs a tuple.\n   */\n  static tuple<A, B, C, D, E, F, G, H>(\n    a: A,\n    b: B,\n    c: C,\n    d: D,\n    e: E,\n    f: F,\n    g: G,\n    h: H,\n  ): Tuple8<A, B, C, D, E, F, G, H>;\n  static tuple<A, B, C, D, E, F, G>(\n    a: A,\n    b: B,\n    c: C,\n    d: D,\n    e: E,\n    f: F,\n    g: G,\n  ): Tuple7<A, B, C, D, E, F, G>;\n  static tuple<A, B, C, D, E, F>(a: A, b: B, c: C, d: D, e: E, f: F): Tuple6<A, B, C, D, E, F>;\n  static tuple<A, B, C, D, E>(a: A, b: B, c: C, d: D, e: E): Tuple5<A, B, C, D, E>;\n  static tuple<A, B, C, D>(a: A, b: B, c: C, d: D): Tuple4<A, B, C, D>;\n  static tuple<A, B, C>(a: A, b: B, c: C): Tuple3<A, B, C>;\n  static tuple<A, B>(a: A, b: B): Tuple2<A, B>;\n  static tuple<A>(a: A): Tuple1<A>;\n  static tuple(): Tuple0;\n  static tuple(...values: unknown[]): unknown {\n    // Special case for 0-tuples\n    if (values.length === 0) {\n      // Only construct if needed\n      if (tuple0 === undefined) {\n        tuple0 = new Tuple([], localToken) as any;\n      }\n      return tuple0;\n    }\n    return getDefaultLazy(tupleKey, () => new Tuple(values, localToken), getLeaf(values));\n  }\n  static symbol<A, B, C, D, E, F, G, H>(\n    a: A,\n    b: B,\n    c: C,\n    d: D,\n    e: E,\n    f: F,\n    g: G,\n    h: H,\n  ): CompositeSymbol8<A, B, C, D, E, F, G, H>;\n  static symbol<A, B, C, D, E, F, G>(\n    a: A,\n    b: B,\n    c: C,\n    d: D,\n    e: E,\n    f: F,\n    g: G,\n  ): CompositeSymbol7<A, B, C, D, E, F, G>;\n  static symbol<A, B, C, D, E, F>(\n    a: A,\n    b: B,\n    c: C,\n    d: D,\n    e: E,\n    f: F,\n  ): CompositeSymbol6<A, B, C, D, E, F>;\n  static symbol<A, B, C, D, E>(a: A, b: B, c: C, d: D, e: E): CompositeSymbol5<A, B, C, D, E>;\n  static symbol<A, B, C, D>(a: A, b: B, c: C, d: D): CompositeSymbol4<A, B, C, D>;\n  static symbol<A, B, C>(a: A, b: B, c: C): CompositeSymbol3<A, B, C>;\n  static symbol<A, B>(a: A, b: B): CompositeSymbol2<A, B>;\n  static symbol<A>(a: A): CompositeSymbol1<A>;\n  static symbol(): typeof CompositeSymbol0;\n  static symbol(...values: any[]): any {\n    return getDefaultLazy(symbolKey, () => Symbol(), getLeaf(values));\n  }\n\n  /**\n   * A tuple whose members are allowed to all be primitive,\n   * so it can't be garbage-collected and should only be used\n   * in advanced contexts.\n   */\n  static unsafe(...values: any[]): any {\n    return getDefaultLazy(\n      tupleKey,\n      () => new UnsafeTuple(values, localToken),\n      getUnsafeLeaf(values),\n    );\n  }\n\n  static unsafeSymbol(...values: any[]): any {\n    return getDefaultLazy(symbolKey, Symbol, getUnsafeLeaf(values));\n  }\n\n  [Symbol.iterator](): IterableIterator<A> {\n    return arraylikeToIterable(this);\n  }\n}\n\n// Root cache keys for each tuple type\nconst tupleKey = Symbol();\nconst symbolKey = Symbol();\n\nconst cache = new WeakishMap();\n\n// Token used to prevent calling the constructor from other modules\nconst localToken = Symbol();\n\nconst initWeakish = () => new WeakishMap();\nlet tuple0: Tuple0;\n\n/**\n * Tries to use the first non-primitive from value list as the root key and throws\n * if there's only primitives.\n */\nexport const getLeaf = (values: any[], unsafe?: boolean): WeakishMap<any, any> => {\n  const rootValue = values.find(isObject);\n  if (!rootValue && !unsafe) {\n    // Throw since it's not possible to weak-reference objects by primitives, only by other objects\n    throw TypeError('At least one value must be of type object');\n  }\n  // If the first value is not an object, pad the values with the first object\n  const root = rootValue === values[0] ? cache : getDefaultLazy(rootValue, initWeakish, cache);\n  return values.reduce((prev, curr) => getDefaultLazy(curr, initWeakish, prev), root);\n};\n\n// Unsafe tuples aren't garbage collected so it's more efficient to just use a normal map\nconst unsafeCache = new Map();\nconst initUnsafe = () => new Map();\nclass UnsafeTuple<A> extends Tuple<A> {}\n/**\n * A memory-leaky, slightly more efficient version of `getLeaf()`.\n */\nexport const getUnsafeLeaf = (values: any[]): Map<any, any> =>\n  values.reduce((prev, curr) => getDefaultLazy(curr, initUnsafe, prev), unsafeCache);\n\nexport const { tuple, symbol } = Tuple;\n\nexport const unsafe = Tuple.unsafe as typeof tuple;\nexport const unsafeSymbol = Tuple.unsafeSymbol as typeof tuple;\n\n// Expose constructor to be used for `instanceof`\ntuple.constructor = Tuple;\nunsafe.constructor = UnsafeTuple;\n","import Tuple from './Tuple';\nimport { isObject } from './helpers';\n\n/**\n * Recursively creates a \"composite key\" (like a \"value identity\") for\n * an object's entries (key-value pairs).\n */\n// tslint:disable-next-line: variable-name\nconst DeepCompositeSymbol = (object: any, filter?: (entry: [string, any]) => boolean) => {\n  const entries = filter ? Object.entries(object).filter(filter) : Object.entries(object);\n  // Recursively replace non-tuple object values with tuples\n  entries.forEach(entry => update(entry, filter));\n  return Tuple.unsafeSymbol(...flatten(entries));\n};\n\nexport const shallowKey = Symbol('shallow');\nexport const shallowCache = new WeakSet<object>();\nexport const shallow = <A extends object>(a: A): A => {\n  shallowCache.add(a);\n  return a;\n};\n\nconst update = (entry: [string, any], filter?: any) => {\n  const value = entry[1];\n  if (\n    isObject(value) &&\n    !(value as any)[shallowKey] &&\n    !(value instanceof Tuple) &&\n    !shallowCache.has(value)\n  ) {\n    entry[1] = DeepCompositeSymbol(value, filter);\n  }\n};\n\nconst flatten = (entries: any[][]) => Array.prototype.concat.apply([], entries);\n\nexport default DeepCompositeSymbol;\n","import DeepCompositeSymbol from './DeepCompositeSymbol';\nimport { isObject } from './helpers';\n\n/**\n * Works somewhat similarly to Record in the Record & Tuple proposal:\n * https://github.com/tc39/proposal-record-tuple\n */\n// tslint:disable-next-line: variable-name\nconst ValueObject = <A extends any>(target: A, filter?: (entry: [string, any]) => boolean): A => {\n  if (!isObject(target)) {\n    return target;\n  }\n  const key = DeepCompositeSymbol(target, filter);\n  if (cache.has(key)) {\n    return cache.get(key) as A;\n  }\n  cache.set(key, target);\n  return target;\n};\n\nconst cache = new Map<symbol, object>();\n\nexport default ValueObject;\n","import { getLeaf } from './Tuple';\nimport { getDefaultLazy } from './helpers';\n\nconst defaultCache = new WeakMap();\n\nexport const memoize = <A extends Function>(fn: A, cache = defaultCache): A => {\n  const memoized: any = function(this: any, ...args: any[]) {\n    const node = getLeaf([memoized, this, ...args]);\n    return getDefaultLazy(node, () => fn.apply(this, args), defaultCache);\n  };\n  return memoized as A;\n};\n","import Tuple from './Tuple';\n\nexport interface Settable<A, B> {\n  set(key: A, value: B): this;\n}\n\nexport interface Gettable<A, B> {\n  get(key: A): B | undefined;\n}\n\nexport interface GenericMap<A, B> extends GetSettable<A, B> {\n  has(key: A): boolean;\n}\n\nexport type GetSettable<A, B> = Settable<A, B> & Gettable<A, B>;\n\nexport type Primitive = boolean | undefined | null | number | string | symbol;\n\nexport interface Tuple0 extends Tuple<never> {\n  readonly length: 0;\n}\n/** Singleton */\nexport interface Tuple1<A> extends Tuple<A> {\n  readonly 0: A;\n  readonly length: 1;\n}\n/** Pair */\nexport interface Tuple2<A, B> extends Tuple<A | B> {\n  readonly 0: A;\n  readonly 1: B;\n  readonly length: 2;\n}\n/** Triple */\nexport interface Tuple3<A, B, C> extends Tuple<A | B | C> {\n  readonly 0: A;\n  readonly 1: B;\n  readonly 2: C;\n  readonly length: 3;\n}\n/** Quadruple */\nexport interface Tuple4<A, B, C, D> extends Tuple<A | B | C | D> {\n  readonly 0: A;\n  readonly 1: B;\n  readonly 2: C;\n  readonly 3: D;\n  readonly length: 4;\n}\n/** Quintuple */\nexport interface Tuple5<A, B, C, D, E> extends Tuple<A | B | C | D | E> {\n  readonly 0: A;\n  readonly 1: B;\n  readonly 2: C;\n  readonly 3: D;\n  readonly 4: E;\n  readonly length: 5;\n}\n/** Sextuple */\nexport interface Tuple6<A, B, C, D, E, F> extends Tuple<A | B | C | D | E | F> {\n  readonly 0: A;\n  readonly 1: B;\n  readonly 2: C;\n  readonly 3: D;\n  readonly 4: E;\n  readonly 5: F;\n  readonly length: 6;\n}\n/** Septuple */\nexport interface Tuple7<A, B, C, D, E, F, G> extends Tuple<A | B | C | D | E | F | G> {\n  readonly 0: A;\n  readonly 1: B;\n  readonly 2: C;\n  readonly 3: D;\n  readonly 4: E;\n  readonly 5: F;\n  readonly 6: G;\n  readonly length: 7;\n}\n/** Octuple */\nexport interface Tuple8<A, B, C, D, E, F, G, H> extends Tuple<A | B | C | D | E | F | G | H> {\n  readonly 0: A;\n  readonly 1: B;\n  readonly 2: C;\n  readonly 3: D;\n  readonly 4: E;\n  readonly 5: F;\n  readonly 6: G;\n  readonly 7: H;\n  readonly length: 8;\n}\n\nexport type CompositeSymbol<T> = {\n  t: T;\n} & symbol;\n// tslint:disable-next-line: variable-name\nexport const CompositeSymbol0: CompositeSymbol<[never]> = Symbol('CompositeSymbol0') as any;\nexport type CompositeSymbol1<A> = CompositeSymbol<[A]>;\nexport type CompositeSymbol2<A, B> = CompositeSymbol<[A, B]>;\nexport type CompositeSymbol3<A, B, C> = CompositeSymbol<[A, B, C]>;\nexport type CompositeSymbol4<A, B, C, D> = CompositeSymbol<[A, B, C, D]>;\nexport type CompositeSymbol5<A, B, C, D, E> = CompositeSymbol<[A, B, C, D, E]>;\nexport type CompositeSymbol6<A, B, C, D, E, F> = CompositeSymbol<[A, B, C, D, E, F]>;\nexport type CompositeSymbol7<A, B, C, D, E, F, G> = CompositeSymbol<[A, B, C, D, E, F, G]>;\nexport type CompositeSymbol8<A, B, C, D, E, F, G, H> = CompositeSymbol<[A, B, C, D, E, F, G, H]>;\n\nexport interface Indexable<A> {\n  [i: number]: A;\n}\n"],"names":["cache"],"mappings":"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"}