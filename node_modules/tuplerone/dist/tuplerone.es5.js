/**
 * Gets a map element, lazily initializing it with a default value.
 */
const getDefaultLazy = (key, init, target) => {
    if (!target.has(key)) {
        const value = init();
        target.set(key, value);
        return value;
    }
    return target.get(key);
};
/**
 * Tests if a value is an object.
 *
 * Doesn't test for symbols because symbols are invalid as `WeakMap` keys.
 */
const isObject = (x) => x !== null && (typeof x === 'object' || typeof x === 'function');
const forEach = (iterator, callback) => {
    do {
        const { value, done } = iterator.next();
        if (done) {
            break;
        }
        callback(value);
    } while (true);
};
/**
 * Sets all items from an iterable as index properties on the target object.
 */
const assignArraylike = (iterator, target) => {
    let i = 0;
    forEach(iterator, (value) => {
        target[i] = value;
        i += 1;
    });
    return i;
};
const arraylikeToIterable = (source) => {
    let i = 0;
    return {
        next() {
            let done;
            let value;
            if (i < source.length) {
                done = false;
                value = source[i];
                i += 1;
            }
            else {
                done = true;
                // Issue: https://github.com/Microsoft/TypeScript/issues/2983
                value = undefined;
            }
            return {
                done,
                value,
            };
        },
        [Symbol.iterator]() {
            return arraylikeToIterable(source);
        },
    };
};

/**
 * A generic wrapper to Map and WeakMap that can use both non-primitives
 * (objects and symbols) and primitives as keys, creating the underlying
 * storage as needed.
 */
class WeakishMap {
    set(k, v) {
        if (isObject(k)) {
            if (!this.weakMap) {
                this.weakMap = new WeakMap();
            }
            this.weakMap.set(k, v);
        }
        else {
            if (!this.map) {
                this.map = new Map();
            }
            this.map.set(k, v);
        }
        return this;
    }
    get(k) {
        if (isObject(k) && this.weakMap) {
            return this.weakMap.get(k);
        }
        if (this.map) {
            return this.map.get(k);
        }
    }
    has(k) {
        if (isObject(k) && this.weakMap) {
            return this.weakMap.has(k);
        }
        if (this.map) {
            return this.map.has(k);
        }
        return false;
    }
}

class Tuple extends Array {
    /**
     * @throws {TypeError} Will throw if called non-locally; use the tuple() method instead.
     */
    constructor(iterable, confirm) {
        super();
        this.length = 0;
        // TODO: make configurable or remove? it currently breaks subclassing
        if (confirm !== localToken) {
            throw TypeError('The `Tuple.tuple()` method must be used to construct');
        }
        assignArraylike(iterable[Symbol.iterator](), this);
        Object.freeze(this);
    }
    static tuple(...values) {
        // Special case for 0-tuples
        if (values.length === 0) {
            // Only construct if needed
            if (tuple0 === undefined) {
                tuple0 = new Tuple([], localToken);
            }
            return tuple0;
        }
        return getDefaultLazy(tupleKey, () => new Tuple(values, localToken), getLeaf(values));
    }
    static symbol(...values) {
        return getDefaultLazy(symbolKey, () => Symbol(), getLeaf(values));
    }
    /**
     * A tuple whose members are allowed to all be primitive,
     * so it can't be garbage-collected and should only be used
     * in advanced contexts.
     */
    static unsafe(...values) {
        return getDefaultLazy(tupleKey, () => new UnsafeTuple(values, localToken), getUnsafeLeaf(values));
    }
    static unsafeSymbol(...values) {
        return getDefaultLazy(symbolKey, Symbol, getUnsafeLeaf(values));
    }
    [Symbol.iterator]() {
        return arraylikeToIterable(this);
    }
}
// Root cache keys for each tuple type
const tupleKey = Symbol();
const symbolKey = Symbol();
const cache = new WeakishMap();
// Token used to prevent calling the constructor from other modules
const localToken = Symbol();
const initWeakish = () => new WeakishMap();
let tuple0;
/**
 * Tries to use the first non-primitive from value list as the root key and throws
 * if there's only primitives.
 */
const getLeaf = (values, unsafe) => {
    const rootValue = values.find(isObject);
    if (!rootValue && !unsafe) {
        // Throw since it's not possible to weak-reference objects by primitives, only by other objects
        throw TypeError('At least one value must be of type object');
    }
    // If the first value is not an object, pad the values with the first object
    const root = rootValue === values[0] ? cache : getDefaultLazy(rootValue, initWeakish, cache);
    return values.reduce((prev, curr) => getDefaultLazy(curr, initWeakish, prev), root);
};
// Unsafe tuples aren't garbage collected so it's more efficient to just use a normal map
const unsafeCache = new Map();
const initUnsafe = () => new Map();
class UnsafeTuple extends Tuple {
}
/**
 * A memory-leaky, slightly more efficient version of `getLeaf()`.
 */
const getUnsafeLeaf = (values) => values.reduce((prev, curr) => getDefaultLazy(curr, initUnsafe, prev), unsafeCache);
const { tuple, symbol } = Tuple;
const unsafe = Tuple.unsafe;
const unsafeSymbol = Tuple.unsafeSymbol;
// Expose constructor to be used for `instanceof`
tuple.constructor = Tuple;
unsafe.constructor = UnsafeTuple;

/**
 * Recursively creates a "composite key" (like a "value identity") for
 * an object's entries (key-value pairs).
 */
// tslint:disable-next-line: variable-name
const DeepCompositeSymbol = (object, filter) => {
    const entries = filter ? Object.entries(object).filter(filter) : Object.entries(object);
    // Recursively replace non-tuple object values with tuples
    entries.forEach(entry => update(entry, filter));
    return Tuple.unsafeSymbol(...flatten(entries));
};
const shallowKey = Symbol('shallow');
const shallowCache = new WeakSet();
const shallow = (a) => {
    shallowCache.add(a);
    return a;
};
const update = (entry, filter) => {
    const value = entry[1];
    if (isObject(value) &&
        !value[shallowKey] &&
        !(value instanceof Tuple) &&
        !shallowCache.has(value)) {
        entry[1] = DeepCompositeSymbol(value, filter);
    }
};
const flatten = (entries) => Array.prototype.concat.apply([], entries);

/**
 * Works somewhat similarly to Record in the Record & Tuple proposal:
 * https://github.com/tc39/proposal-record-tuple
 */
// tslint:disable-next-line: variable-name
const ValueObject = (target, filter) => {
    if (!isObject(target)) {
        return target;
    }
    const key = DeepCompositeSymbol(target, filter);
    if (cache$1.has(key)) {
        return cache$1.get(key);
    }
    cache$1.set(key, target);
    return target;
};
const cache$1 = new Map();

const defaultCache = new WeakMap();
const memoize = (fn, cache = defaultCache) => {
    const memoized = function (...args) {
        const node = getLeaf([memoized, this, ...args]);
        return getDefaultLazy(node, () => fn.apply(this, args), defaultCache);
    };
    return memoized;
};

// tslint:disable-next-line: variable-name
const CompositeSymbol0 = Symbol('CompositeSymbol0');

export default tuple;
export { symbol as CompositeSymbol, CompositeSymbol0, DeepCompositeSymbol, tuple as Tuple, unsafeSymbol as UnsafeCompositeSymbol, unsafe as UnsafeTuple, ValueObject, memoize, shallow, shallowKey };
//# sourceMappingURL=tuplerone.es5.js.map
